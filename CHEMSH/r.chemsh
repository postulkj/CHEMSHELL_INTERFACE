#!/bin/bash

#ChemShell
export LIBTCL=/home/postulka/programs/chemshell/tcl8.5.19/lib/libtcl8.5.so
export PATH=/home/postulka/programs/chemshell/tcl8.5.19/bin:$PATH
export PATH=/home/postulka/programs/chemshell/chemsh-tcl-3.7.1-int8/scripts:$PATH
export PATH=/home/postulka/programs/chemshell/chemsh-tcl-3.7.1-int8/bin:$PATH
export TCLROOT=/home/postulka/programs/chemshell/tcl8.5.19/build
export TCLLIBPATH=/home/postulka/programs/chemshell/chemsh-tcl-3.7.1-int8/tcl
export LD_LIBRARY_PATH=/home/postulka/programs/chemshell/tcl8.5.19/build/lib:$LD_LIBRARY_PATH

#MNDO
source SetEnvironment.sh MNDO
source SetEnvironment.sh ORCA 5.0.3

cd CHEMSH
timestep=$1
ibead=$2
input=input$ibead
natom=$(wc -l ../geom.dat.$ibead) && natom=$(echo "${natom%% *}")
geometry=../geom.dat.$ibead


#################### USER INPUT #######################
QMatom=24               # Number of QM atoms
extra_con=0             # Extra conectivity entries 
hamiltonian="pm3"       # QM method
basis="cc-pVDZ"     
charge=0
mult=1
embedding="shift"       #shift for electrostatic embedding
types_qm_atoms="nx nx cx cx cx cx cx cx cx hx hx hx hx hx cx cx cx cx cx hx hx hx hx hx"
types_mm_atoms="c o h h h ho"
qm_theory="mndo: { executable=$MNDOEXE hamiltonian=$hamiltonian charge=$charge mult=$mult }"
#qm_theory="orca: { executable=$ORCAEXE version=5.0 hamiltonian=dft charge=$charge mult=$mult functional=$hamiltonian basis=$basis }"

##################### NON-BONDED PARAMETERS FOR QM ATOMS ######################
# Every row represents one atom type and its epsilon and sigma parameters.
# Here units of kJ/mol and nm are expected.
# These parameters will be transformed and added to dl_poly input file ff.dat. Pair rules will be applied on them and on those found in ff.dat.
cat > non_bonded.dat << EOF
nx 0.71128  0.325
cx 0.276144 0.35
hx 0.12552  0.25
EOF

#################### END OF USER INPUT ################

# Get unique types for both sets
readarray -t unique_qm_types < <(echo "$types_qm_atoms" | tr ' ' '\n' | awk '!x[$0]++')
readarray -t unique_mm_types < <(echo "$types_mm_atoms" | tr ' ' '\n' | awk '!x[$0]++')


echo $natom > input.xyz
echo '' >> input.xyz
cat $geometry >> input.xyz
geometry=input.xyz
MMatom=$( echo "$natom-$QMatom" | bc )
############ DL_POLY INPUT  ###################

if [ ! -f ff.dat ]; then
for qm_type in "${unique_qm_types[@]}"; do
    echo "declare $qm_type" >> ff.dat
done

cat >> ff.dat << EOF

charge  c   +.145
charge  h   +.04
charge  o   -.683
charge  ho  +.418
charge  n   -.460

vdw     c c     485.30       892114.23
vdw     h h     29.30        7152.56
vdw     o o     627.24       578580.84
vdw     ho ho   0.0          0.0
vdw     n  n    801.33       944298.39
EOF

# Transform non-bonded parameters to dl_poly format
while read -r line; do
    atom_type=$(echo $line | awk '{print $1}')
    epsilon=$(echo $line | awk '{print $2}')
    sigma=$(echo $line | awk '{print $3}')
    sigma_angstrom=$(echo "$sigma * 10" | bc)
    epsilon_kcal=$(echo "$epsilon / 4.184" | bc -l)
    c6=$(echo "$epsilon_kcal * 4 * $sigma_angstrom^6" | bc -l)
    c12=$(echo "$c6 * $sigma_angstrom^6" | bc -l)
    echo "vdw $atom_type $atom_type $c6 $c12" >> qm_non-bonded.dat
done < non_bonded.dat


for mm_type in "${unique_mm_types[@]}"; do
    for qm_type in "${unique_qm_types[@]}"; do
        # Example: retrieve c6 and c12 for each type (replace with your actual code/logic)
        c6_mm=$(awk -v type="$mm_type" '$1 == "vdw" && $2 == type && $3 == type {print $4}' ff.dat)
        c12_mm=$(awk -v type="$mm_type" '$1 == "vdw" && $2 == type && $3 == type {print $5}' ff.dat)
        c6_qm=$(awk -v type="$qm_type" '$1 == "vdw" && $2 == type && $3 == type {print $4}' qm_non-bonded.dat)
        c12_qm=$(awk -v type="$qm_type" '$1 == "vdw" && $2 == type && $3 == type {print $5}' qm_non-bonded.dat)
        if [[ -n "$c6_mm" && -n "$c6_qm" && -n "$c12_mm" && -n "$c12_qm" ]]; then
            c6=$(echo "scale=10; sqrt($c6_mm * $c6_qm)" | bc -l)
            c12=$(echo "scale=10; sqrt($c12_mm * $c12_qm)" | bc -l)
            LC_NUMERIC=C printf "vdw %s %s %.4f %.4f\n" "$mm_type" "$qm_type" "$c6" "$c12" >> ff.dat
        fi
    done
done

# This defines parameters for MM calculation and most importantly atom types as combination types_qm_atoms and types from geometry file.
# Alternatively atom types can be defined as types_qm_atoms and a multiplication of types_mm_atoms.
if [ -n "$types_mm_atoms" ]; then
    # Count number of residue form MMatom and length ov types_mm_atoms_all
    length_residue=$(echo $types_mm_atoms | wc -w)
    nresidue=$(echo $MMatom / $length_residue | bc)
    # Create types_mm_atoms_all as a repetition of types_mm_atoms_all
    types_mm_atoms_all=$(for i in $(seq 1 $nresidue); do echo -n "$types_mm_atoms "; done)
else
    types_mm_atoms_all=$(for atom in $(tail -$MMatom $geometry | awk '{print $1}'); do echo -n "${atom,      ,} "; done)
fi

dl_defs="{ mm_defs=ff.dat mxlist=10000 use_pairlist=no conn=geom.c atom_types= { $types_qm_atoms $types_mm_atoms_all } } " 


cat > geom.com << EOF

read_xyz file=$geometry coords=geom.c

EOF

cat > $input.com << EOF
eandg energy=e gradient=g coords=geom.c \
    theory= hybrid : { coupling=$embedding
    qm_region= { $(seq  -s " " 1 $QMatom) }
    qm_theory=$qm_theory
    mm_theory=dl_poly : {$dl_defs}
    }

EOF

fi

############ END OF DL_POLY INPUT #####################

chemsh -s --no-xml-output  >& geom.com.out <geom.com

natom4=`expr $natom + 4`
connectNUM=` expr $[$natom - $QMatom] / 6 \* 5 + $extra_con`
count=`expr $QMatom + 1`
mv geom.c pom.dat
head -n $natom4 pom.dat >> geom.c
if [ $timestep -eq 0 ]; then
echo "block = connectivity records = $connectNUM" > conn.dat
while [ $count -le $natom ]; do
        echo "$count $(echo "$count+1" | bc)" >> conn.dat
        echo "$count $(echo "$count+2" | bc)" >> conn.dat
        echo "$count $(echo "$count+3" | bc)" >> conn.dat
        echo "$count $(echo "$count+4" | bc)" >> conn.dat
        echo "$(echo "$count+1" | bc) $(echo "$count+5" | bc)" >> conn.dat
        count=`expr $count + 6`

done
cat conn.dat >> geom.c
else
cat conn.dat >> geom.c
fi

#################### Launch ChemShell ####################

chemsh.x $input.com > $input.com.out

if [[ $? -eq 1 ]];then
    echo "Error in ChemShell. Check $input.com.out"
elif $( grep -q grep 'error code 1' $input.com.out ) ;then
    echo "Error in QM code."
else
    cp $input.com.out $input.com.out.old
    cp g g.old
    cp e e.old
fi

##########################################################

#################### get energies and gradient ###############

nwrite=$(awk -F"[! ,=\"']+" '{if($1=="nwrite")print $2}' ../input.in)
pom=$(echo $timestep % $nwrite | bc)
if [ $timestep -eq 1 ] && [ $nwrite -ne 1 ]; then
        printf "Step \t Potential \t  Kinetic \t Total\n" >> ../energiesQMMM.dat
elif [ $nwrite -eq 1 ]; then
        if [ $timestep -eq 0 ]; then
                printf "Step \t PotentialQMMM \t PotentialMM \t PotentialQM \t  Kinetic \t Total\n" >> ../energiesQMMM.dat
        elif [ $timestep -eq 1 ]; then
        grep 'QM/MM Energy' $input.com.out | awk '{ print $3 }'  > QMMMenergy.dat
        grep 'energy from' $input.com.out | grep 'dl_poly' | awk '{ print $6 }' > MMenergy.dat
        grep 'energy from' input001.com.out | grep 'mndo' | awk '{ print $6 }' > QMenergy.dat
        else
        QMMM_pot_energy=$(cat QMMMenergy.dat)
        MM_pot_energy=$(cat MMenergy.dat)
        QM_pot_energy=$(cat QMenergy.dat)
            Ekin=$(awk '{ print $3}' ../energies.dat | tail -1)
            QMMM_tot_energy=$(echo $QMMM_pot_energy + $Ekin | bc)
        laststep=$(echo $timestep - 1 | bc)
        printf " $laststep \t $QMMM_pot_energy \t $MM_pot_energy \t $QM_pot_energy \t $Ekin \t $QMMM_tot_energy\n" >> ../energiesQMMM.dat
        grep 'QM/MM Energy' $input.com.out | awk '{ print $3 }' > QMMMenergy.dat
        grep 'energy from' $input.com.out | grep 'dl_poly' | awk '{ print $6 }' > MMenergy.dat
        grep 'energy from' input001.com.out | grep 'mndo' | awk '{ print $6 }' > QMenergy.dat
        fi
else
        if [ $pom -eq 1 ]; then
        QMMM_pot_energy=$(cat QMMMenergy.dat)
        MM_pot_energy=$(cat MMenergy.dat)
        QM_pot_energy=$(cat QMenergy.dat)
            Ekin=$(awk '{ print $3}' ../energies.dat | tail -1)
            QMMM_tot_energy=$(echo $QMMM_pot_energy + $Ekin | bc)
        laststep=$(echo $timestep - 1 | bc)
        printf " $laststep \t $QMMM_pot_energy \t $MM_pot_energy \t $QM_pot_energy \t  $Ekin \t $QMMM_tot_energy\n" >> ../energiesQMMM.dat
        elif [ $pom -eq 0 ]; then
        grep 'QM/MM Energy' $input.com.out | awk '{ print $3 }' > QMMMenergy.dat
        grep 'energy from' $input.com.out | grep 'dl_poly' | awk '{ print $6 }' > MMenergy.dat
        grep 'energy from' input001.com.out | grep 'mndo' | awk '{ print $6 }' > QMenergy.dat
        fi

fi


tail -1 e >> ../engrad.dat.$ibead
paste <(sed -n '5~3p' g) <(sed -n '6~3p' g) <(sed -n '7~3p' g) >> ../engrad.dat.$ibead

cp input001.com.out input001.com.out.$timestep
cp mndo.out mndo.out.$timestep
cp ../engrad.dat.$ibead engrad.dat.$timestep
